<!DOCTYPE html>
<html lang="ja"><head>
<title>多倍長演算</title>
<meta http-equiv="content-type" charset="utf-8">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>









</head>
<body style="margin-top : 0px;margin-left : 0px;margin-right : 0px;margin-bottom : 0px;" bgcolor="#eeeeee">
<div align="center">
  <table summary="メインテーブル" width="800" cellspacing="0" cellpadding="0" bgcolor="#ffffff">
    <tbody>


      

      <tr>
        <td bgcolor="#ffffff" align="center">
        <table width="800" cellspacing="0">
          <tbody>
          
            <tr>
		<td width="60" height="60" bgcolor="#ffffff" align="left">
		<canvas id="Canvas1" width="60" height="60"></canvas>
		<script>
      		var canvas1 = document.getElementById("Canvas1");
      		var context = canvas1.getContext('2d');
		let ctx1 = canvas1.getContext('2d');
		ctx1.beginPath();
		let g = ctx1.createRadialGradient(30, 30, 20, 30, 30, 30);
		g.addColorStop(0.0, 'yellow');
		g.addColorStop(1.0, 'black');
		ctx1.fillStyle = g;
		ctx1.fillRect(0, 0, 60, 60);
		ctx1.fillStyle = "#6600ff";
		ctx1.arc(30, 30, 20, 0, 360/180*Math.PI);
		ctx1.fill();

		ctx1.beginPath();
		ctx1.fillStyle = "#ffffff";
		ctx1.arc(35, 30, 15, 0, 360/180*Math.PI);
		ctx1.fill();
    		</script>
		</td>
		<td width="340" height="60" bgcolor="#ffffff" align=left" valign="top"><font size="3" face="Impact">Kazuki Matsushita's Homepage</font>
		<br><font size="2">色々なネタを紹介していきます</font></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="index.html"><font size="2">HOME</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="jikoshoukai.html"><font size="2">自己紹介</font></a></td>
                <td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">ブログ</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="develop.html"><font size="2">トピック</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">リンク</font></a></td>
            </tr>
          </tbody>
        </table>
     
       	<hr>

        <br>
	<table>
        <tr>
	<div style="font-size: 16pt; color: #000000; background-color: #ccccff">
		多倍長演算
	</div>
	<tr>
	</table>
	</br>


        <table width="750" border="0">
          <tbody>
		<td width="750" bgcolor="#ffffff" align="left" valign="bottom">
	<font size="5">背景</font>
	<hr>
<font size="3">現在使われているパソコンは64bitのものがほとんどだと思います。Windows XP世代のパソコンは32bitが多いみたいです。
32bitのパソコンの問題点はメモリが約4.3GB(2の32乗バイト)までしか使うことができないことで（いわゆる4GBの壁）、この関係から今のパソコンは64bitが主流になっています。(ちなみに遥か昔の16bitのパソコンは65536バイトのメモリしか使えなかったというのだから恐ろしい)
<br>
一方で現在主流のパソコンが64bitである関係上、計算プログラムなどに使われる変数は64bit長が一般的です。（64bit変数同士の計算を最も効率的に行えるため）
64bit整数は約±922京までの整数を表現でき、倍精度浮動小数点型は10進数で15桁の精度を持つため一般的な用途のプログラムでは十分ですが、公開鍵暗号の実装や円周率の計算、高精度のシミュレーションでは64bitでは不十分で何千bitもの桁数の数字を扱うことがあるので普通のlong int型（Windowsの場合はlong long int型）で計算すると桁が溢れます。
このような場合、多倍長演算をソフトウェアで実装する必要があります。この方法について論じていこうと思います。</font>

<br>
<br>
<br>
<br>
	<font size="5">基礎知識</font>
<hr>
<font size="3">
64bitのCPUによってハードウェアで扱える数値型にはどのようなものがあるのでしょうか。以下にその具体例を並べてみました。
<br>
<br>

<table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
                <tbody>
                  <tr>
                <td width="170" bgcolor="#f4f4f4">型名</td>
                <td width="170" bgcolor="#f4f4f4">C言語での型</td>
		<td width="170" bgcolor="#f4f4f4">扱える数値</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">8bit整数型</td>
                <td bgcolor="#ffffff">char</td>
		<td bgcolor="#ffffff">-128～+127</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">8bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned char</td>
		<td bgcolor="#ffffff">0～+255</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">16bit整数型</td>
                <td bgcolor="#ffffff">short</td>
		<td bgcolor="#ffffff">-32,768～+32,767</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">16bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned short</td>
		<td bgcolor="#ffffff">0～+65,535</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">32bit整数型</td>
                <td bgcolor="#ffffff">int</td>
		<td bgcolor="#ffffff">-2,147,483,648～+2,147,483,647</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">32bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned int</td>
		<td bgcolor="#ffffff">0～+4,294,967,295</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">64bit整数型</td>
                <td bgcolor="#ffffff">long long int</td>
		<td bgcolor="#ffffff">-9,223,372,036,854,775,808～+9,223,372,036,854,775,807</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">64bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned long long int</td>
		<td bgcolor="#ffffff">0～+18,446,744,073,709,551,615</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">半精度(16bit)浮動小数点型</td>
                <td bgcolor="#ffffff"></td>
		<td bgcolor="#ffffff">+-6.10×10^-5～6.55×10^4</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">単精度(32bit)浮動小数点型</td>
                <td bgcolor="#ffffff">float</td>
		<td bgcolor="#ffffff">+-1.18×10^-38 ～ 3.40×10^38</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">倍精度(64bit)浮動小数点型</td>
                <td bgcolor="#ffffff">double</td>
		<td bgcolor="#ffffff">+-2.23×10^-308 ～ 1.79×10^308</td>
                  </tr>

                </tbody>
              </table>


<br>
整数型は一番桁の大きいビットを符号、それ以外のビットを数値に使っています。（unsigned～は全ビットを数値に用いています）
<br>
一方で浮動小数点型は少し複雑です。半精度(16bit)浮動小数点型は10bit、単精度(32bit)浮動小数点型は23bit、倍精度(64bit)浮動小数点型は52bitを仮数部（有効数字）に当てています。図で表すとこんな感じです。
<br>
<img src="float.png" alt="float">
<br>
<img src="double.png" alt="double">
<br>
<br>
C言語の場合、多倍長整数演算は64bit整数型の組み合わせで作るのが一般的ですが、Javascriptの数値型は全てdouble型であるため浮動小数点型を用いて実装してみようと思います。


</font>
<br>
<br>
<br>
<br>


<font size="5">実装</font>
<hr>
<font size="3">
倍精度浮動小数点型は2進数で52桁、10進数にして15桁の精度を持ちます。つまり演算の結果がこの桁数より低い桁に収まれば丸め誤差は発生しないということになります。
10進数⇔2進数の基数変換は今回は実装しないので10進数のまま実装します。
この場合、乗算の結果が15桁以内になる最大桁数である7桁×7桁を1変数に割り当てればいいことになります。(7桁×8桁でもいいがプログラムが複雑になる割には対して速くならないため今回は7桁×7桁で実装)
<br>
多倍長変数を7桁ずつに分割してdouble型の配列に格納し、それぞれの要素を1つの桁として計算するため実態は10000000進数同士の二項演算となります。
<br>
<br>
<img src="long_explain1.png" alt="long_explain1">

<br>
<br>
<br>
<font size="4">●加算・減算</font>
<br>
加算の場合は多倍長整数を格納した配列を下の桁からそれぞれ逐次的に加算・繰り上がり処理を行うことで実装します。（10000000進数の筆算です）
<br>
減算の場合も同様ですが、計算結果がマイナスになる場合があるため注意が必要です。
<br>
なお、加減算の計算コストは\(O(n)\)となります。





<br>
<br>
<br>
<font size="4">●乗算</font>
<br>
乗算に関しては筆算よりも高速なアルゴリズムが存在しますが、桁数が小さい場合は必ずしも高速とは言えないため桁数に応じて使い分ける必要があります。
<br>
筆算の場合は2つの配列の各要素を全ての組み合わせで掛ける必要があるので計算コストは\(O(n^{2})\)となります。これはもう説明不要ですね。
<br>
<br>
筆算よりも高速なアルゴリズムとして、カラツバ法があります。これは多倍長整数を上位と下位の桁に2分割することにより乗算の回数が4分の3になることを利用したものです。
桁数が大きい場合は何度も分割することでその度に乗算コストが4分の3になるため桁数が大きくなるほど筆算に比べて高速化します。
桁数が2倍になると計算量が3倍になるため計算量は\(O(n^{\log_{2}3})=O(n^{1.585})\)となります。
<br>
例としてXとYの積Zを求める場合を考えます。XとYを次のように上位と下位の桁で分割すると次のように表せます。
\[
X=bx_1+x_0
\]
\[
Y=by_1+y_0
\]
ここでbは分割の基数です。(例えば 12345678 = 10000×1234 + 5678 の10000に相当)
<br>
この時Zを以下のように表すものとします。
\[
Z=b^{2}z_2+bz_1+z_0
\]
Zを計算するためには筆算では以下のような4回の乗算が必要です。
\[
z_2=x_1・y_1
\]
\[
z_1=x_1・y_0+x_0・y_1
\]
\[
z_0=x_0・y_0
\]
カラツバ法では以下の順番で計算を実行することにより乗算回数を3回に減らします。
\[
z_2=x_1・y_1
\]
\[
z_0=x_0・y_0
\]
\[
z_1=z_2+z_0-(x_1-x_0)・(y_1-y_0)
\]
加減算の回数は大幅に増えますが、計算コストの大きい乗算回数が減ることで全体的な計算コストが減ることになります。
<br>
カラツバ法を分割数について一般化したものがToom-Cook法です。
3分割の場合の計算量は\(O(n^{\log_{3}5})=O(n^{1.465})\)となります。
<br>
<br>
T00m-Cook法より高速なアルゴリズムとして、FFT(高速フーリエ変換)を利用した方法があります。FFTを用いるとn要素のフーリエ変換が\(O(n\log{n})\)で計算可能で、
フーリエ変換を行うと畳み込みが各要素ごとの積に変換されるので、これを逆フーリエ変換すると多倍長整数の積が得られます。
<br>
多倍長整数の乗算の場合は通常のフーリエ変換ではなく整数環フーリエ変換（pを法とする1の原始p乗根を回転子として用いる）が使われます。
法とする数pは要素数より大きくなければならず、各要素ごとに桁数に比例した計算量を必要とするため計算量は\(O(n\log{n}・\log{\log{n}})\)となります。




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<font size="5">テスト</font>
<hr>
<font size="3">
半角数字、整数のみ
<form name="test" action="#">
    <p>a1:</p>
    <p><textarea name="a1" id="a1" cols="100" rows="5" onkeyup="strcheck(this.form, this.value)"></textarea></p>
    <p>a2:</p>
    <p><textarea name="a2" id="a2" cols="100" rows="5" onkeyup="strcheck(this.form, this.value)"></textarea></p>
<input type="button" value="a1+a2" onclick="tas()">
<input type="button" value="a1-a2" onclick="hik()">
<input type="button" value="a1*a2" onclick="kakel()">
<input type="button" value="a1/a2" onclick="wal()">
<input type="button" value="a1^a2" onclick="jou()">
<input type="button" value="a1!" onclick="kaijou()">
<input type="button" value="clear" onclick="clr()"><br>
<p><textarea name="result" cols="100" rows="30" readonly></textarea></p>
</form>

<script>
function strcheck(frm,obj){
var chr1 = test.a1.value;
var str;
var errorcode = 0;
if(chr1.length>5000){
errorcode = 0;
}
for(var i=0;i<chr1.length;i++){
str = chr1.charAt(i);
if(str=="-"&&i!=0){
errorcode = 3;
}
if(str!=0&&str!=1&&str!=2&&str!=3&&str!=4&&str!=5&&str!=6&&str!=7&&str!=8&&str!=9&&str!="-"){
errorcode = 2;
}
}
var chr2 = test.a2.value;
if(chr2.length>5000){
errorcode = 0;
}
for(var i=0;i<chr2.length;i++){
str = chr2.charAt(i);
if(str=="-"&&i!=0){
errorcode = 3;
}
if(str!=0&&str!=1&&str!=2&&str!=3&&str!=4&&str!=5&&str!=6&&str!=7&&str!=8&&str!=9&&str!="-"){
errorcode = 2;
}
}


if(errorcode==1){
test.result.value = "エラー：文字数オーバー";
}
else if(errorcode==2){
test.result.value = "エラー：入力不可能な文字が含まれています。";
}
else if(errorcode==3){
test.result.value = "エラー：マイナスの位置が間違っています。";
}
else{
test.result.value = "";
}
}




















function tas(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;


//マイナスが付いてるか判定
if(chr1.charAt(0)=="-"){
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}



//chrを配列にしてr_chrに格納(マイナスが付いている場合マイナスを除いて格納)
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//和演算
if(sign_a1==0 && sign_a2==0){
RES = add(NA1,NA2);
sign_res=0;
}
else if(sign_a1==1 && sign_a2==1){
RES = add(NA1,NA2);
sign_res=1;
}
else if(sign_a1==0 && sign_a2==1){
RES = sub(NA1,NA2);
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==1 && sign_a2==0){
RES = sub(NA2,NA1);
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



//結果がマイナスの場合先頭にマイナスを追加
if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}
test.result.value = res;
}




















function hik(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;


//マイナスが付いてるか判定
if(chr1.charAt(0)=="-"){
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}




//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//差演算
if(sign_a1==0 && sign_a2==0){
RES = sub(NA1,NA2);
//演算結果がマイナスの場合の処理
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==1 && sign_a2==1){
RES = sub(NA2,NA1);
//演算結果がマイナスの場合の処理
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==0 && sign_a2==1){
RES = add(NA1,NA2);
}
else if(sign_a1==1 && sign_a2==0){
RES = add(NA1,NA2);
sign_res=1;
}



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



//結果がマイナスの場合先頭にマイナスを追加
if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function kakel(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}

if(sign_a1==1&&sign_a2==0){
sign_res=1;
}
else if(sign_a1==0&&sign_a2==1){
sign_res=1;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//積演算
RES = mul(NA1,NA2);



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function wal(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}

if(sign_a1==1&&sign_a2==0){
sign_res=1;
}
else if(sign_a1==0&&sign_a2==1){
sign_res=1;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//除演算
RES = div(NA1,NA2);



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function jou(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}


//chrを配列にしてr_chrに格納
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-7*Math.floor(chr1.length/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-7*Math.floor(chr2.length/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<chr1.length/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<chr2.length/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}


//指数演算
RES.push(1);
for(i=0;i<Number(chr2);i++){
RES = mul(NA1,RES);
}


for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}


//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function kaijou(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var NAI=[]
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}


//chrを配列にしてr_chrに格納
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-7*Math.floor(chr1.length/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-7*Math.floor(chr2.length/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<chr1.length/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<chr2.length/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}


//階乗演算
RES.push(1);
NAI.push(0)
for(i=1;i<=Number(chr1);i++){
NAI[0]=i
RES = mul(NAI,RES);
}


for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i]);
}


//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}





















function kakel_karatsuba(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}

if(sign_a1==1&&sign_a2==0){
sign_res=1;
}
else if(sign_a1==0&&sign_a2==1){
sign_res=1;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//積演算
RES = mul_karatsuba(NA1,NA2);



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}


















function add(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}

//和演算
RES.push(NA1[0]+NA2[0]);
for(i=1;i<lenmax;i++){
RES.push(NA1[i]+NA2[i]);
RES[i]+=Math.floor(RES[i-1]/10000000);
RES[i-1]-=10000000*Math.floor(RES[i-1]/10000000);
}

//最大桁の桁あふれ処理
if(Math.floor(RES[lenmax-1]/10000000)!=0){
RES.push(Math.floor(RES[lenmax-1]/10000000));
RES[lenmax-1]-=10000000*Math.floor(RES[lenmax-1]/10000000);
}


return RES;
}




















function sub(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}



//差演算
RES.push(NA1[0]-NA2[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA1[i]-NA2[i]-1);
}
else{
RES.push(NA1[i]-NA2[i]);
}
}

//最大桁がマイナスになった場合
if(RES[lenmax-1]<0){
//配列RESを空にする
RES.splice(0,RES.length);
//NA1とNA2を入れ替えて引き算
RES.push(NA2[0]-NA1[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA2[i]-NA1[i]-1);
}
else{
RES.push(NA2[i]-NA1[i]);
}
}
//全要素をマイナスにする
for(i=0;i<lenmax;i++){
RES[i]=(-1)*RES[i];
}
}


//不要な0削除
var na1length = NA1.length;
for(i=0;i<na1length;i++){
if(NA1[na1length-i-1]!=0){
break;
}
else if(NA1.length!=1){
NA1.pop();
}
}

var na2length = NA2.length;
for(i=0;i<na2length;i++){
if(NA2[na2length-i-1]!=0){
break;
}
else if(NA2.length!=1){
NA2.pop();
}
}

var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
else if(RES.length!=1){
RES.pop();
}
}

return RES;
}
















function mul(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = NA1.length + NA2.length;

for(i=0;i<lenmax;i++){
RES.push(0)
}
//積演算
for(j=0;j<NA2.length;j++){
RES[j] += NA1[0]*NA2[j];
for(i=1;i<NA1.length;i++){
RES[i+j] += NA1[i]*NA2[j];
RES[i+j] += Math.floor(RES[i+j-1]/10000000);
RES[i+j-1] -= 10000000*Math.floor(RES[i+j-1]/10000000);
}
RES[NA1.length+j] += Math.floor(RES[NA1.length+j-1]/10000000);
RES[NA1.length+j-1] -= 10000000*Math.floor(RES[NA1.length+j-1]/10000000);
}

//不要な0削除
for(i=0;i<lenmax;i++){
if(RES[lenmax-i-1]!=0){
break;
}
RES.pop()
}

return RES;
}




















function mul_karatsuba(NA1,NA2){
var i,j,k,len1,len2,c1,c2,cmax;
var RES=[];
var N1=[];
var N2=[];
var N1_0=[];
var N1_1=[];
var N2_0=[];
var N2_1=[];

len1=NA1.length;
c1 = 0;	//分割回数
while(len1>=8){
len1 = Math.floor(len1/2);
c1 += 1;
}

len2=NA2.length;
c2 = 0;	//分割回数
while(len2>=8){
len2 = Math.floor(len2/2);
c2 += 1;
}

cmax = Math.max(c1,c2);
console.log(cmax);


if(cmax==0){
//N1,N2に格納
for(i=0;i<NA1.length;i++){
N1.push(NA1[i]);
}
for(i=0;i<NA2.length;i++){
N2.push(NA2[i]);
}
}

else{
//NA1,NA2を分割して格納
for(i=0;i<Math.floor(NA1.length/2);i++){
N1_0.push(NA1[i]);
}
for(i=Math.floor(NA1.length/2);i<NA1.length;i++){
N1_1.push(NA1[i]);
}
for(i=0;i<Math.floor(NA2.length/2);i++){
N2_0.push(NA2[i]);
}
for(i=Math.floor(NA2.length/2);i<NA2.length;i++){
N2_1.push(NA2[i]);
}

}



RES = mul(NA1,NA2);

return RES;
}




















function div_old(NA1,NA2){
var i,j,k,Q;
var RES=[];
var DIVIDENT=[];	//割られる数をNA2の桁にそろえたもの
var QUOTIENT=[];	//商の一桁
var DIVIDENTSUB=[];	//DIVIDENTから引く数
var SUBR=[];	//余り
var KETA=[];
var COMP;	//SUBRとNA2の大小比較用
var breaks = 1;	//for文抜け出し用
var VAR	//デバッグ用


QUOTIENT.push(0);
DIVIDENTSUB.push(0);
SUBR.push(0);
KETA.push(10000000);
i=0;


if(NA1.length<NA2.length){
RES.push(0);
}

else{
//DIVIDENT初期化
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT.push(0);
}
//NA1からNA2と同じ桁数の要素を取り出してDIVIDENTに格納
k=0;
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT[k] = NA1[j];
k += 1;
}

for(i=0 ; i<NA1.length-NA2.length+1 ; i++){
if(DIVIDENT.length==NA2.length){
//DIVIDENTの最大桁÷NA2の最大桁を仮にQUOTIENTと置く
QUOTIENT[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/NA2[NA2.length-1]);
}
else{
QUOTIENT[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/NA2[NA2.length-1]);
}
breaks=0;
while(breaks==0){
//QUOTIENTにNA2を掛けたDIVIDENTSUBをDIVIDENTと比較
DIVIDENTSUB = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTSUB);
if(SUBR[SUBR.length-1]<0){
QUOTIENT[0] -= 1;
breaks=0;
}
else{
breaks=1;
}
}
//RESに追加
RES.unshift(QUOTIENT[0]);
//DIVIDENTを初期化
for(j=0 ; j<DIVIDENT.length ; j++){
DIVIDENT[j] = 0;
}
//DIVIDENTに次の桁を代入してSUBRを加算
DIVIDENT[0] = NA1[NA1.length-NA2.length-1-i];
SUBR = mul(KETA,SUBR);
DIVIDENT = add(DIVIDENT,SUBR);
}	//forに対応
}	//elseに対応


//不要な0削除
var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
RES.pop()
}


return RES;
}





















function div(NA1,NA2){
var i,j,k,Q;
var RES=[];
var DIVIDENT=[];	//割られる数をNA2の桁にそろえたもの
var QUOTIENT=[];	//商の一桁
var QUOTIENT_MAX=[];	//商の一桁の上界
var QUOTIENT_MIN=[];
var DIVIDENTQ=[];	//DIVIDENTから引く数
var SUBR=[];	//余り
var ADDR=[];	//余りからNA2を引いたもの
var KETA=[];
var COMP;	//SUBRとNA2の大小比較用
var breaks = 1;	//for文抜け出し用
var VAR	//デバッグ用


QUOTIENT.push(0);
QUOTIENT_MAX.push(0);
QUOTIENT_MIN.push(0);
DIVIDENTQ.push(0);
SUBR.push(0);
ADDR.push(0);
KETA.push(10000000);
i=0;


if(NA1.length<NA2.length){
RES.push(0);
}

else{
//DIVIDENT初期化
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT.push(0);
}
//NA1からNA2と同じ桁数の要素を取り出してDIVIDENTに格納
k=0;
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT[k] = NA1[j];
k += 1;
}

for(i=0 ; i<NA1.length-NA2.length+1 ; i++){
if(DIVIDENT.length==NA2.length){
//DIVIDENTの最大桁÷NA2の最大桁をQUOTIENT_MAXと置く
QUOTIENT_MAX[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/(NA2[NA2.length-1]+1));
}
else{
//前回の余りを足した場合
if(DIVIDENT.length>1){
QUOTIENT_MAX[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/(NA2[NA2.length-1]+1));
}
//DIVIDENTの長さが1の場合
else{
QUOTIENT_MAX[0] = Math.floor((DIVIDENT[DIVIDENT.length-1])/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor((DIVIDENT[DIVIDENT.length-1])/(NA2[NA2.length-1]+1));
}
}
QUOTIENT[0] = QUOTIENT_MAX[0];

breaks=0;
//QUOTIENTにNA2を掛けたDIVIDENTQをDIVIDENTと比較
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
while(breaks==0){
//余りが負になった場合、QUOTIENTとQUOTIENT_MINの平均をQUOTIENTに代入
if(SUBR[SUBR.length-1]<0){
QUOTIENT[0] = Math.floor((QUOTIENT_MIN[0]+QUOTIENT[0])/2);
//もしそれでも大きすぎる場合QUOTIENTをQUOTIENT_MAXに代入
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
if(SUBR[SUBR.length-1]<0){
QUOTIENT_MAX[0] = QUOTIENT[0];
}
if(ADDR[ADDR.length-1]>=0){
QUOTIENT_MIN[0] = QUOTIENT[0];
}
breaks=0;
}
//余りがNA2より大きくなった場合、QUOTIENTとQUOTIENT_MANの平均をQUOTIENTに代入し、それをQUOTIENT_MINに代入
else if(ADDR[ADDR.length-1]>=0){
QUOTIENT[0] = Math.floor((QUOTIENT_MAX[0]+QUOTIENT[0])/2);
//もしそれでも小さすぎる場合QUOTIENTをQUOTIENT_MAXに代入
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
if(SUBR[SUBR.length-1]<0){
QUOTIENT_MAX[0] = QUOTIENT[0];
}
if(ADDR[ADDR.length-1]>=0){
QUOTIENT_MIN[0] = QUOTIENT[0];
}
breaks=0;
}
else{
breaks=1;
}
}

//RESに追加
RES.unshift(QUOTIENT[0]);
//DIVIDENTを初期化
for(j=0 ; j<DIVIDENT.length ; j++){
DIVIDENT[j] = 0;
}
//DIVIDENTに次の桁を代入してSUBRを加算
DIVIDENT[0] = NA1[NA1.length-NA2.length-1-i];
SUBR = mul(KETA,SUBR);
DIVIDENT = add(DIVIDENT,SUBR);
}	//forに対応
}	//elseに対応


//不要な0削除
var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
else if(RES.length!=1){
RES.pop()
}
}


return RES;
}




















function clr(){
test.a1.value = "";
test.a2.value = "";
test.result.value = "";
}
</script>


</font>





</td>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <tr>
              <td width="200" align="center">







</td>
              <td>
              
              </td>
            </tr>

          </tbody>
        </table>


	<br>
        <table width="780" border="0">
         
		<tbody>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <td width="200" align="center">
              

              <td>
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
              
        
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
                

              </table>
              </td>
            </tr>
            
          </tbody>
        </table>
       



            </tr>
          </tbody>
        </table>
        <br>
        <br>
        <br>
        </td>
      </tr>
      <tr>
        <td style="height : 50px;" valign="bottom" bgcolor="#0000ff" align="center">
	<a href="index.html">HOME</a>｜
	<a href="jikoshoukai.html">自己紹介</a>｜
	<a href="">ブログ</a>｜
	<a href="develop.html">トピック</a> |
	<a href="">リンク</a></td>
      </tr>
      <tr>
        <td style="height : 50px;" bgcolor="#0000ff" align="center"><font style="font-size : 8pt;" color="#000000">&nbsp;<br>
        掲載内容の無断転載は禁じます。</font></td>
      </tr>
      <tr>
        <td style="font-size : 10pt;color : white;" height="100" bgcolor="#0000ff" background="" align="center"><strong style="font-size : 12pt;"></strong><br>
        連絡先 : kazuki.matsushita[at]icloud.com<br>
        <font style="font-size : 8pt;" color="#000000">Copyright (ｃ) Kazuki Matsushita  　All Rights Reserved.</font></td>
      </tr>
    </tbody>
  </table>
</div>
</body></html>
