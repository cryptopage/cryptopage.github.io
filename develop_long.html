<!DOCTYPE html>
<html lang="ja"><head>
<title>多倍長演算</title>
<meta http-equiv="content-type" charset="utf-8">










</head>
<body style="margin-top : 0px;margin-left : 0px;margin-right : 0px;margin-bottom : 0px;" bgcolor="#eeeeee">
<div align="center">
  <table summary="メインテーブル" width="800" cellspacing="0" cellpadding="0" bgcolor="#ffffff">
    <tbody>


      

      <tr>
        <td bgcolor="#ffffff" align="center">
        <table width="800" cellspacing="0">
          <tbody>
          
            <tr>
		<td width="60" height="60" bgcolor="#ffffff" align="left">
		<canvas id="Canvas1" width="60" height="60"></canvas>
		<script>
      		var canvas1 = document.getElementById("Canvas1");
      		var context = canvas1.getContext('2d');
		let ctx1 = canvas1.getContext('2d');
		ctx1.beginPath();
		let g = ctx1.createRadialGradient(30, 30, 20, 30, 30, 30);
		g.addColorStop(0.0, 'yellow');
		g.addColorStop(1.0, 'black');
		ctx1.fillStyle = g;
		ctx1.fillRect(0, 0, 60, 60);
		ctx1.fillStyle = "#6600ff";
		ctx1.arc(30, 30, 20, 0, 360/180*Math.PI);
		ctx1.fill();

		ctx1.beginPath();
		ctx1.fillStyle = "#ffffff";
		ctx1.arc(35, 30, 15, 0, 360/180*Math.PI);
		ctx1.fill();
    		</script>
		</td>
		<td width="340" height="60" bgcolor="#ffffff" align=left" valign="top"><font size="3" face="Impact">Kazuki Matsushita's Homepage</font>
		<br><font size="2">色々なネタを紹介していきます</font></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="index.html"><font size="2">HOME</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="jikoshoukai.html"><font size="2">自己紹介</font></a></td>
                <td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">ブログ</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="develop.html"><font size="2">開発したもの</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">リンク</font></a></td>
            </tr>
          </tbody>
        </table>
     
       	<hr>

        <br>
	<table>
        <tr>
	<div style="font-size: 16pt; color: #000000; background-color: #ccccff">
		多倍長演算
	</div>
	<tr>
	</table>
	</br>


        <table width="750" border="0">
          <tbody>
		<td width="750" bgcolor="#ffffff" align="left" valign="bottom">
	<font size="5">背景</font>
	<hr>
<font size="3">現在使われているパソコンは64bitのものがほとんどだと思います。Windows XP世代のパソコンは32bitが多いみたいです。
32bitのパソコンの問題点はメモリが約4.3GB(2の32乗バイト)までしか使うことができないことで（いわゆる4GBの壁）、この関係から今のパソコンは64bitが主流になっています。(ちなみに遥か昔の16bitのパソコンは65536バイトのメモリしか使えなかったというのだから恐ろしい)
<br>
一方で現在主流のパソコンが64bitである関係上、計算プログラムなどに使われる変数は64bit長が一般的です。（64bit変数同士の計算を最も効率的に行えるため）
64bit整数は約±922京までの整数を表現でき、倍精度浮動小数点型は10進数で15桁の精度を持つため一般的な用途のプログラムでは十分ですが、公開鍵暗号の実装や円周率の計算、高精度のシミュレーションでは64bitでは不十分で何千bitもの桁数の数字を扱うことがあるので普通のlong int型（Windowsの場合はlong long int型）で計算すると桁が溢れます。
このような場合、多倍長演算をソフトウェアで実装する必要があります。この方法について論じていこうと思います。</font>

<br>
<br>
<br>
<br>
	<font size="5">基礎知識</font>
<hr>
<font size="3">
64bitのCPUによってハードウェアで扱える数値型にはどのようなものがあるのでしょうか。以下にその具体例を並べてみました。
<br>
<br>

<table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
                <tbody>
                  <tr>
                <td width="170" bgcolor="#f4f4f4">型名</td>
                <td width="170" bgcolor="#f4f4f4">C言語での型</td>
		<td width="170" bgcolor="#f4f4f4">扱える数値</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">8bit整数型</td>
                <td bgcolor="#ffffff">char</td>
		<td bgcolor="#ffffff">-128～+127</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">8bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned char</td>
		<td bgcolor="#ffffff">0～+255</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">16bit整数型</td>
                <td bgcolor="#ffffff">short</td>
		<td bgcolor="#ffffff">-32,768～+32,767</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">16bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned short</td>
		<td bgcolor="#ffffff">0～+65,535</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">32bit整数型</td>
                <td bgcolor="#ffffff">int</td>
		<td bgcolor="#ffffff">-2,147,483,648～+2,147,483,647</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">32bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned int</td>
		<td bgcolor="#ffffff">0～+4,294,967,295</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">64bit整数型</td>
                <td bgcolor="#ffffff">long long int</td>
		<td bgcolor="#ffffff">-9,223,372,036,854,775,808～+9,223,372,036,854,775,807</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">64bit整数型（符合なし）</td>
                <td bgcolor="#ffffff">unsigned long long int</td>
		<td bgcolor="#ffffff">0～+18,446,744,073,709,551,615</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">半精度(16bit)浮動小数点型</td>
                <td bgcolor="#ffffff"></td>
		<td bgcolor="#ffffff">+-6.10×10^-5～6.55×10^4</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">単精度(32bit)浮動小数点型</td>
                <td bgcolor="#ffffff">float</td>
		<td bgcolor="#ffffff">+-1.18×10^-38 ～ 3.40×10^38</td>
                  </tr>

                  <tr>
                <td bgcolor="#ffffff">倍精度(64bit)浮動小数点型</td>
                <td bgcolor="#ffffff">double</td>
		<td bgcolor="#ffffff">+-2.23×10^-308 ～ 1.79×10^308</td>
                  </tr>

                </tbody>
              </table>


<br>
整数型は一番桁の大きいビットを符号、それ以外のビットを数値に使っています。（unsigned～は全ビットを数値に用いています）
<br>
一方で浮動小数点型は少し複雑です。半精度(16bit)浮動小数点型は10bit、単精度(32bit)浮動小数点型は23bit、倍精度(64bit)浮動小数点型は52bitを仮数部（有効数字）に当てています。図で表すとこんな感じです。
<br>
<img src="float.png" alt="float">
<br>
<img src="double.png" alt="double">
<br>
<br>
Javascriptは浮動小数点型しか使えないため浮動小数点型を用いて実装してみようと思います。


</font>





<br>
<br>
<br>
<br>
<font size="5">テスト</font>
<hr>
<font size="3">
半角数字、整数のみ
<form name="test" action="#">
    <p>a1:</p>
    <p><textarea name="a1" id="a1" cols="100" rows="5" onkeyup="strcheck(this.form, this.value)"></textarea></p>
    <p>a2:</p>
    <p><textarea name="a2" id="a2" cols="100" rows="5" onkeyup="strcheck(this.form, this.value)"></textarea></p>
<input type="button" value="a1+a2" onclick="tas()">
<input type="button" value="a1-a2" onclick="hik()">
<input type="button" value="a1*a2" onclick="kakel()">
<input type="button" value="a1/a2" onclick="wal()">
<input type="button" value="a1^a2" onclick="jou()">
<input type="button" value="a1!" onclick="kaijou()">
<input type="button" value="clear" onclick="clr()"><br>
<p><textarea name="result" cols="100" rows="30" readonly></textarea></p>
</form>

<script>
function strcheck(frm,obj){
var chr1 = test.a1.value;
var str;
var errorcode = 0;
if(chr1.length>5000){
errorcode = 1;
}
for(var i=0;i<chr1.length;i++){
str = chr1.charAt(i);
if(str=="-"&&i!=0){
errorcode = 3;
}
if(str!=0&&str!=1&&str!=2&&str!=3&&str!=4&&str!=5&&str!=6&&str!=7&&str!=8&&str!=9&&str!="-"){
errorcode = 2;
}
}
var chr2 = test.a2.value;
if(chr2.length>5000){
errorcode = 1;
}
for(var i=0;i<chr2.length;i++){
str = chr2.charAt(i);
if(str=="-"&&i!=0){
errorcode = 3;
}
if(str!=0&&str!=1&&str!=2&&str!=3&&str!=4&&str!=5&&str!=6&&str!=7&&str!=8&&str!=9&&str!="-"){
errorcode = 2;
}
}


if(errorcode==1){
test.result.value = "エラー：文字数オーバー";
}
else if(errorcode==2){
test.result.value = "エラー：入力不可能な文字が含まれています。";
}
else if(errorcode==3){
test.result.value = "エラー：マイナスの位置が間違っています。";
}
else{
test.result.value = "";
}
}




















function tas(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;


//マイナスが付いてるか判定
if(chr1.charAt(0)=="-"){
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}



//chrを配列にしてr_chrに格納(マイナスが付いている場合マイナスを除いて格納)
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//和演算
if(sign_a1==0 && sign_a2==0){
RES = add(NA1,NA2);
sign_res=0;
}
else if(sign_a1==1 && sign_a2==1){
RES = add(NA1,NA2);
sign_res=1;
}
else if(sign_a1==0 && sign_a2==1){
RES = sub(NA1,NA2);
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==1 && sign_a2==0){
RES = sub(NA2,NA1);
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



//結果がマイナスの場合先頭にマイナスを追加
if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}
test.result.value = res;
}




















function hik(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;


//マイナスが付いてるか判定
if(chr1.charAt(0)=="-"){
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}




//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//差演算
if(sign_a1==0 && sign_a2==0){
RES = sub(NA1,NA2);
//演算結果がマイナスの場合の処理
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==1 && sign_a2==1){
RES = sub(NA2,NA1);
//演算結果がマイナスの場合の処理
if(RES[RES.length-1]<0){
sign_res=1;
for(i=0;i<RES.length;i++){
RES[i]=(-1)*RES[i];
}
}
}
else if(sign_a1==0 && sign_a2==1){
RES = add(NA1,NA2);
}
else if(sign_a1==1 && sign_a2==0){
RES = add(NA1,NA2);
sign_res=1;
}



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



//結果がマイナスの場合先頭にマイナスを追加
if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function kakel(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}

if(sign_a1==1&&sign_a2==0){
sign_res=1;
}
else if(sign_a1==0&&sign_a2==1){
sign_res=1;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//積演算
RES = prod(NA1,NA2);



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function wal(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}
if(chr2.charAt(0)=="-"){
sign_a2=1;
}
else{
sign_a2=0;
}

if(sign_a1==1&&sign_a2==0){
sign_res=1;
}
else if(sign_a1==0&&sign_a2==1){
sign_res=1;
}



//chrを配列にしてr_chrに格納
if(sign_a1==0){
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a1==1){
for(i=1;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
}
if(sign_a2==0){
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}
if(sign_a2==1){
for(i=1;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-sign_a1-7*Math.floor((chr1.length-sign_a1)/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-sign_a2-7*Math.floor((chr2.length-sign_a2)/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<(chr1.length-sign_a1)/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<(chr2.length-sign_a2)/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}



//除演算
RES = div(NA1,NA2);



for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}



if(sign_res==1){
res += "-";
}



//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function jou(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}


//chrを配列にしてr_chrに格納
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-7*Math.floor(chr1.length/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-7*Math.floor(chr2.length/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<chr1.length/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<chr2.length/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}


//指数演算
RES.push(1);
for(i=0;i<Number(chr2);i++){
RES = prod(NA1,RES);
}


for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}


//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}




















function kaijou(){
var i,j;
var m10;
var chr1 = test.a1.value;
var chr2 = test.a2.value;
var r_chr1=[];
var r_chr2=[];
var NA1=[];
var NA2=[];
var NAI=[]
var nNA1=[];
var nNA2=[];
var RES=[];
var RES_rev=[];
var na1="";
var na2="";
var res="";
m10=1;
var sign_a1=0; //0なら正、1なら負
var sign_a2=0;
var sign_res=0;
var resd50;

if(chr1.charAt(0)=="-"){ //マイナスが付いてるか判定
sign_a1=1;
}
else{
sign_a1=0;
}


//chrを配列にしてr_chrに格納
for(i=0;i<chr1.length;i++){
r_chr1.unshift(chr1.charAt(i));
}
for(i=0;i<chr2.length;i++){
r_chr2.unshift(chr2.charAt(i));
}



//桁数が7の倍数ではない場合に余った桁を0で埋める
for(i=0;i<7-(chr1.length-7*Math.floor(chr1.length/7));i++){
r_chr1.push(0);
}
for(i=0;i<7-(chr2.length-7*Math.floor(chr2.length/7));i++){
r_chr2.push(0);
}



//格納
for(i=0;i<chr1.length/7;i++){
NA1.push(Number(r_chr1[7*i])+10*Number(r_chr1[7*i+1])+100*Number(r_chr1[7*i+2])+1000*Number(r_chr1[7*i+3])
+10000*Number(r_chr1[7*i+4])+100000*Number(r_chr1[7*i+5])+1000000*Number(r_chr1[7*i+6])); 
}
for(i=0;i<chr2.length/7;i++){
NA2.push(Number(r_chr2[7*i])+10*Number(r_chr2[7*i+1])+100*Number(r_chr2[7*i+2])+1000*Number(r_chr2[7*i+3])
+10000*Number(r_chr2[7*i+4])+100000*Number(r_chr2[7*i+5])+1000000*Number(r_chr2[7*i+6])); 
}


//階乗演算
RES.push(1);
NAI.push(0)
for(i=1;i<=Number(chr1);i++){
NAI[0]=i
RES = prod(NAI,RES);
}


for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i]);
}


//出力用にstr型に変換
res += String(RES_rev[0]);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}


test.result.value = res;
}



















function add(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}

//和演算
RES.push(NA1[0]+NA2[0]);
for(i=1;i<lenmax;i++){
RES.push(NA1[i]+NA2[i]);
RES[i]+=Math.floor(RES[i-1]/10000000);
RES[i-1]-=10000000*Math.floor(RES[i-1]/10000000);
}

//最大桁の桁あふれ処理
if(Math.floor(RES[lenmax-1]/10000000)!=0){
RES.push(Math.floor(RES[lenmax-1]/10000000));
RES[lenmax-1]-=10000000*Math.floor(RES[lenmax-1]/10000000);
}


return RES;
}




















function sub(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}




//差演算
RES.push(NA1[0]-NA2[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA1[i]-NA2[i]-1);
}
else{
RES.push(NA1[i]-NA2[i]);
}
}

//最大桁がマイナスになった場合
if(RES[lenmax-1]<0){
//配列RESを空にする
RES.splice(0,RES.length);
//NA1とNA2を入れ替えて引き算
RES.push(NA2[0]-NA1[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA2[i]-NA1[i]-1);
}
else{
RES.push(NA2[i]-NA1[i]);
}
}
//全要素をマイナスにする
for(i=0;i<lenmax;i++){
RES[i]=(-1)*RES[i];
}
}



//不要な0削除
for(i=0;i<lenmax;i++){
if(RES[lenmax-i-1]!=0){
break;
}
else if(RES.length!=1){
RES.pop();
}
}

return RES;
}
















function prod(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = NA1.length + NA2.length;

for(i=0;i<lenmax;i++){
RES.push(0)
}
//積演算
for(j=0;j<NA2.length;j++){
RES[j] += NA1[0]*NA2[j];
for(i=1;i<NA1.length;i++){
RES[i+j] += NA1[i]*NA2[j];
RES[i+j] += Math.floor(RES[i+j-1]/10000000);
RES[i+j-1] -= 10000000*Math.floor(RES[i+j-1]/10000000);
}
RES[NA1.length+j] += Math.floor(RES[NA1.length+j-1]/10000000);
RES[NA1.length+j-1] -= 10000000*Math.floor(RES[NA1.length+j-1]/10000000);
}

//不要な0削除
for(i=0;i<lenmax;i++){
if(RES[lenmax-i-1]!=0){
break;
}
RES.pop()
}

return RES;
}




















function prod_karatsuba(NA1,NA2){
var i,j,k;
var RES=[];
}




















function div(NA1,NA2){
var i,j,k,Q;
var RES=[];
var DIVIDENT=[];	//割られる数をNA2の桁にそろえたもの
var QUOTIENT=[];	//商の一桁
var DIVIDENTSUB=[];	//DIVIDENTから引く数
var SUBR=[];	//余り
var KETA=[];
var COMP;	//SUBRとNA2の大小比較用
var breaks = 1;	//for文抜け出し用
var VAR	//デバッグ用


QUOTIENT.push(0);
DIVIDENTSUB.push(0);
SUBR.push(0);
KETA.push(10000000);
i=0;


if(NA1.length<NA2.length){
RES.push(0);
}

else{
//DIVIDENT初期化
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT.push(0);
}
//NA1からNA2と同じ桁数の要素を取り出してDIVIDENTに格納
k=0;
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT[k] = NA1[j];
k += 1;
}

for(i=0 ; i<NA1.length-NA2.length+1 ; i++){
if(DIVIDENT.length==NA2.length){
//DIVIDENTの最大桁÷NA2の最大桁を仮にQUOTIENTと置く
QUOTIENT[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/NA2[NA2.length-1]);
}
else{
QUOTIENT[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/NA2[NA2.length-1]);
}
breaks=0;
while(breaks==0){
//QUOTIENTにNA2を掛けたDIVIDENTSUBをDIVIDENTと比較
DIVIDENTSUB = prod(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTSUB);
if(SUBR[SUBR.length-1]<0){
QUOTIENT[0] -= 1;
breaks=0;
}
else{
breaks=1;
}
}
//RESに追加
RES.unshift(QUOTIENT[0]);
//DIVIDENTを初期化
for(j=0 ; j<DIVIDENT.length ; j++){
DIVIDENT[j] = 0;
}
//DIVIDENTに次の桁を代入してSUBRを加算
DIVIDENT[0] = NA1[NA1.length-NA2.length-1-i];
SUBR = prod(KETA,SUBR);
DIVIDENT = add(DIVIDENT,SUBR);
}	//forに対応
}	//elseに対応


//不要な0削除
for(i=0;i<lenmax;i++){
if(RES[lenmax-i-1]!=0){
break;
}
RES.pop()
}


return RES;
}





















function clr(){
test.a1.value = "";
test.a2.value = "";
test.result.value = "";
}
</script>


</font>





</td>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <tr>
              <td width="200" align="center">
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>






</td>
              <td>
              
              </td>
            </tr>
            <tr>
              <td colspan="2" align="right"><a href="#0">ページ上部へ▲</a></td>
            </tr>
          </tbody>
        </table>


	<br>
        <table width="780" border="0">
         
		<tbody>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <td width="200" align="center">
              

              <td>
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
              
        
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
                

              </table>
              </td>
            </tr>
            
          </tbody>
        </table>
       



            </tr>
          </tbody>
        </table>
        <br>
        <br>
        <br>
        </td>
      </tr>
      <tr>
        <td style="height : 50px;" valign="bottom" bgcolor="#0000ff" align="center">
	<a href="index.html">HOME</a>｜
	<a href="jikoshoukai.html">自己紹介</a>｜
	<a href="">ブログ</a>｜
	<a href="develop.html">開発したもの</a> |
	<a href="">リンク</a></td>
      </tr>
      <tr>
        <td style="height : 50px;" bgcolor="#0000ff" align="center"><font style="font-size : 8pt;" color="#000000">&nbsp;<br>
        掲載内容の無断転載は禁じます。</font></td>
      </tr>
      <tr>
        <td style="font-size : 10pt;color : white;" height="100" bgcolor="#0000ff" background="" align="center"><strong style="font-size : 12pt;"></strong><br>
        連絡先 : kmatsushita@keio.jp<br>
        <font style="font-size : 8pt;" color="#000000">Copyright (ｃ) Kazuki Matsushita  　All Rights Reserved.</font></td>
      </tr>
    </tbody>
  </table>
</div>
</body></html>