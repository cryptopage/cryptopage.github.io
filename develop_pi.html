<!DOCTYPE html>
<html lang="ja"><head>
<title>円周率の計算</title>
<meta http-equiv="content-type" charset="utf-8">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"></script>









</head>
<body style="margin-top : 0px;margin-left : 0px;margin-right : 0px;margin-bottom : 0px;" bgcolor="#eeeeee">
<div align="center">
  <table summary="メインテーブル" width="800" cellspacing="0" cellpadding="0" bgcolor="#ffffff">
    <tbody>


      

      <tr>
        <td bgcolor="#ffffff" align="center">
        <table width="800" cellspacing="0">
          <tbody>
          
            <tr>
		<td width="60" height="60" bgcolor="#ffffff" align="left">
		<canvas id="Canvas1" width="60" height="60"></canvas>
		<script>
      		var canvas1 = document.getElementById("Canvas1");
      		var context = canvas1.getContext('2d');
		let ctx1 = canvas1.getContext('2d');
		ctx1.beginPath();
		let g = ctx1.createRadialGradient(30, 30, 20, 30, 30, 30);
		g.addColorStop(0.0, 'yellow');
		g.addColorStop(1.0, 'black');
		ctx1.fillStyle = g;
		ctx1.fillRect(0, 0, 60, 60);
		ctx1.fillStyle = "#6600ff";
		ctx1.arc(30, 30, 20, 0, 360/180*Math.PI);
		ctx1.fill();

		ctx1.beginPath();
		ctx1.fillStyle = "#ffffff";
		ctx1.arc(35, 30, 15, 0, 360/180*Math.PI);
		ctx1.fill();
    		</script>
		</td>
		<td width="340" height="60" bgcolor="#ffffff" align=left" valign="top"><font size="3" face="Impact">Kazuki Matsushita's Homepage</font>
		<br><font size="2">色々なネタを紹介していきます</font></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="index.html"><font size="2">HOME</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="jikoshoukai.html"><font size="2">自己紹介</font></a></td>
                <td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">ブログ</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href="develop.html"><font size="2">トピック</font></a></td>
		<td width="80" height="60" bgcolor="#ffffff" align="center" valign="bottom"><a href=""><font size="2">リンク</font></a></td>
            </tr>
          </tbody>
        </table>
     
       	<hr>

        <br>
	<table>
        <tr>
	<div style="font-size: 16pt; color: #000000; background-color: #ccccff">
		円周率の計算
	</div>
	<tr>
	</table>
	</br>


        <table width="750" border="0">
          <tbody>
		<td width="750" bgcolor="#ffffff" align="left" valign="bottom">
	<font size="5">ベンチマークとしての円周率の計算</font>
	<hr>
<font size="3">
円周率の計算はパソコンの性能評価に用いられています。
今回はそれを試すプログラムを作ってみました。

</font>

<br>
<br>
<br>
<br>
<font size="5">円周率計算法の比較</font>
<hr>
<font size="3">
グレゴリー級数
\[ \arctan(x) = \sum_{n=0}^\infty \frac{(-1)^n}{2n+1}x^{2n+1} = x - \frac{1}{3}x^3 + \frac{1}{5}x^5 - \frac{1}{7}x^7 + \frac{1}{9}x^9 ・・・ \]
を利用しているものを以下に紹介します。
<br>
<br>
<br>
<br>
・ライプニッツの公式：
\[ \frac{\pi}{4} = \arctan1 = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} ・・・ \]
最もシンプルですが収束が非常に遅いことで有名です。桁数に対して計算量が指数関数的に増えます。
<br>
<br>
<br>
<br>
・マチンの公式：
\[ \frac{\pi}{4} = 4\arctan\frac{1}{5} - \arctan\frac{1}{239} \]
級数が2つありますが比較的収束が早いです。桁数に対して計算量が多項式的に増えます。
<br>
<br>

</font>
<br>
<br>
<br>
<br>


<font size="5">テスト</font>
<hr>
<font size="3">
アルゴリズムを変更する場合は再読み込み推奨
<br>
<br>
<form name="test" action="#">
<input type="button" value="start" onclick="start()">
<select name="algorithm">
<option value="">計算アルゴリズムを選択</option>
<option value="leibniz">ライプニッツ</option>
<option value="matin">マチン</option>
</select>
<select name="digits">
<option value="N">桁数を選択</option>
<option value="1000">1000</option>
<option value="2000">2000</option>
<option value="5000">5000</option>
<option value="10000">10000</option>
</select>
<p><textarea name="result" cols="100" rows="30" readonly></textarea></p>
</form>

<script>
var sig=1;
var sig_1=1;
var sig_2=1;
var sig_3=1;
var count=0;
var item=0;	//どっちの項を計算するか識別
var N_1=[];	//1000000...を格納
var N_id=[];	//1を格納
var DENO=[];	//分母を格納
var DENO_1=[];
var DENO_2=[];
var DENO_3=[];
var ODD_1=[];
var ODD_2=[];
var REV=[];	//逆数を格納
var REV_1=[];
var REV_2=[];
var REV_3=[];
var VAR_1=[];
var VAR_2=[];
var VAR_3=[];
var VAR_4=[];
var VAR_5=[];
var VAR_6=[];
var VAR_7=[];
var VAR_8=[];
var VAR_9=[];
var VAR_10=[];
var VAR_11=[];
var VAR_12=[];
var RES_d0=[];




















function start(){
//初期化&格納
N_1=[];
N_id=[];
VAR_1=[];
VAR_2=[];
VAR_3=[];
VAR_4=[];
VAR_5=[];
VAR_6=[];
VAR_7=[];
VAR_8=[];
VAR_9=[];
VAR_10=[];
VAR_11=[];
VAR_12=[];
item=0;
sig=1;
sig_1=1;
sig_2=1;
sig_3=1;
N_id.push(1);
DENO=[];
DENO.push(1);
DENO_1=[];
DENO_1.push(1);
DENO_2=[];
DENO_2.push(1);
DENO_3=[];
DENO_3.push(1);
ODD_1=[];
ODD_1.push(1);
ODD_2=[];
ODD_2.push(1);
RES_d=[];
RES_d0=[];
RES_d0.push(0);
RES=[];
REV=[];
REV_1=[];
REV_2=[];
REV_3=[];


//格納
if(test.digits.value=="1000"){
for(l=0;l<142;l++){
N_1.push(0); 
}
}
else if(test.digits.value=="2000"){
for(l=0;l<285;l++){
N_1.push(0); 
}
}
else if(test.digits.value=="5000"){
for(l=0;l<714;l++){
N_1.push(0); 
}
}
else if(test.digits.value=="10000"){
for(l=0;l<1428;l++){
N_1.push(0); 
}
}
N_1.push(1000000);
RES_d = N_1;


//桁数が選択されていた場合、計算開始
if(test.digits.value!="N"){
if(test.algorithm.value=="leibniz"){
start_leibniz_calc();
}
else if(test.algorithm.value=="matin"){
start_matin_calc();
}
}
}

























function start_leibniz_calc(){
RES_rev=[];
res="";


if(sig==1){
RES_d = add(RES_d,REV);
}
else if(sig==-1){
RES_d = sub(RES_d,REV);
}


RES = mul(RES_d,[4]);

for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}

//出力用にstr型に変換
res += String(RES_rev[0]/1000000);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}
test.result.value = res;

DENO = add(DENO,[2]);
REV = div(N_1,DENO);
sig = sig*(-1);

setTimeout(start_leibniz_calc,10);
}




















function start_matin_calc(){
RES_rev=[];
res="";



if(item==0){
VAR_7 = div(N_1,[5]);
VAR_7 = mul(VAR_7,[4]);
VAR_8 = div(N_1,[239]);
RES_d0 = sub(VAR_7,VAR_8);
DENO_1 = mul(DENO_1,[5]);
DENO_2 = mul(DENO_2,[239]);
}

else {
VAR_5 = mul(ODD_1,DENO_1);
VAR_6 = mul(ODD_1,DENO_2);
if(sig_1==1){
VAR_7 = div(N_1,VAR_5);
VAR_7 = mul(VAR_7,[4]);
VAR_8 = div(N_1,VAR_6);
RES_d0 = add(RES_d0,VAR_7);
RES_d0 = sub(RES_d0,VAR_8);
}
else if(sig_1==-1){
VAR_7 = div(N_1,VAR_5);
VAR_7 = mul(VAR_7,[4]);
VAR_8 = div(N_1,VAR_6);
RES_d0 = sub(RES_d0,VAR_7);
RES_d0 = add(RES_d0,VAR_8);
}
}



RES = mul(RES_d0,[4]);

for(i=0;i<RES.length;i++){
RES_rev.unshift(RES[i])
}

//出力用にstr型に変換
res += String(RES_rev[0]/1000000);
for(i=1;i<RES.length;i++){
res += String(Math.floor(RES_rev[i]/1000000)-10*Math.floor(RES_rev[i]/10000000));
res += String(Math.floor(RES_rev[i]/100000)-10*Math.floor(RES_rev[i]/1000000));
res += String(Math.floor(RES_rev[i]/10000)-10*Math.floor(RES_rev[i]/100000));
res += String(Math.floor(RES_rev[i]/1000)-10*Math.floor(RES_rev[i]/10000));
res += String(Math.floor(RES_rev[i]/100)-10*Math.floor(RES_rev[i]/1000));
res += String(Math.floor(RES_rev[i]/10)-10*Math.floor(RES_rev[i]/100));
res += String(RES_rev[i]-10*Math.floor(RES_rev[i]/10));
}
test.result.value = res;



//DENO_1,DENO_2は初期化されない
DENO_1 = mul(DENO_1,[25]);
DENO_2 = mul(DENO_2,[57121]);

ODD_1 = add(ODD_1,[2]);

sig_1=(-1)*sig_1;

item=1;

timer_id = setTimeout(start_matin_calc,10);
VAR_9 = sub(VAR_7,[0]);
if(VAR_9[VAR_9.length-1]==0){
clearTimeout( timer_id );
}
}





















function add(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}

//和演算
RES.push(NA1[0]+NA2[0]);
for(i=1;i<lenmax;i++){
RES.push(NA1[i]+NA2[i]);
RES[i]+=Math.floor(RES[i-1]/10000000);
RES[i-1]-=10000000*Math.floor(RES[i-1]/10000000);
}

//最大桁の桁あふれ処理
if(Math.floor(RES[lenmax-1]/10000000)!=0){
RES.push(Math.floor(RES[lenmax-1]/10000000));
RES[lenmax-1]-=10000000*Math.floor(RES[lenmax-1]/10000000);
}


return RES;
}




















function sub(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = Math.max(NA1.length,NA2.length);

//桁揃え
for(i=NA1.length;i<lenmax;i++){
NA1.push(0);
}
for(i=NA2.length;i<lenmax;i++){
NA2.push(0);
}




//差演算
RES.push(NA1[0]-NA2[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA1[i]-NA2[i]-1);
}
else{
RES.push(NA1[i]-NA2[i]);
}
}

//最大桁がマイナスになった場合
if(RES[lenmax-1]<0){
//配列RESを空にする
RES.splice(0,RES.length);
//NA1とNA2を入れ替えて引き算
RES.push(NA2[0]-NA1[0]);
for(i=1;i<lenmax;i++){
if(RES[i-1]<0){
RES[i-1]+=10000000;
RES.push(NA2[i]-NA1[i]-1);
}
else{
RES.push(NA2[i]-NA1[i]);
}
}
//全要素をマイナスにする
for(i=0;i<lenmax;i++){
RES[i]=(-1)*RES[i];
}
}



//不要な0削除
var na1length = NA1.length;
for(i=0;i<na1length;i++){
if(NA1[na1length-i-1]!=0){
break;
}
else if(NA1.length!=1){
NA1.pop();
}
}

var na2length = NA2.length;
for(i=0;i<na2length;i++){
if(NA2[na2length-i-1]!=0){
break;
}
else if(NA2.length!=1){
NA2.pop();
}
}

var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
else if(RES.length!=1){
RES.pop();
}
}

return RES;
}
















function mul(NA1,NA2){
var i,j,k;
var RES=[];
lenmax = NA1.length + NA2.length;

for(i=0;i<lenmax;i++){
RES.push(0)
}
//積演算
for(j=0;j<NA2.length;j++){
RES[j] += NA1[0]*NA2[j];
for(i=1;i<NA1.length;i++){
RES[i+j] += NA1[i]*NA2[j];
RES[i+j] += Math.floor(RES[i+j-1]/10000000);
RES[i+j-1] -= 10000000*Math.floor(RES[i+j-1]/10000000);
}
RES[NA1.length+j] += Math.floor(RES[NA1.length+j-1]/10000000);
RES[NA1.length+j-1] -= 10000000*Math.floor(RES[NA1.length+j-1]/10000000);
}

//不要な0削除
for(i=0;i<lenmax;i++){
if(RES[lenmax-i-1]!=0){
break;
}
RES.pop()
}

return RES;
}




















function mul_karatsuba(NA1,NA2){
var i,j,k,len1,len2,len1_sta,len2_sta,c1,c2;
var RES=[];
var N1=[];
var N2=[];

len1=NA1.length;
c1 = 0;	//分割回数
len1_sta = 1;	//揃え桁数
while(len1>1){
len1 = Math.floor(len1/2);
c1 += 1;
len1_sta = 2*len1_sta;
}

len2=NA2.length;
c2 = 0;	//分割回数
len2_sta = 1;	//揃え桁数
while(len2>1){
len2 = Math.floor(len2/2);
c2 += 1;
len2_sta = 2*len2_sta;
}


//N1,N2に格納
for(i=0;i<NA1.length;i++){
N1.push(NA1[i]);
}

for(i=0;i<NA2.length;i++){
N2.push(NA2[i]);
}


return NA1;
}




















function div_old(NA1,NA2){
var i,j,k,Q;
var RES=[];
var DIVIDENT=[];	//割られる数をNA2の桁にそろえたもの
var QUOTIENT=[];	//商の一桁
var DIVIDENTSUB=[];	//DIVIDENTから引く数
var SUBR=[];	//余り
var KETA=[];
var COMP;	//SUBRとNA2の大小比較用
var breaks = 1;	//for文抜け出し用
var VAR	//デバッグ用


QUOTIENT.push(0);
DIVIDENTSUB.push(0);
SUBR.push(0);
KETA.push(10000000);
i=0;


if(NA1.length<NA2.length){
RES.push(0);
}

else{
//DIVIDENT初期化
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT.push(0);
}
//NA1からNA2と同じ桁数の要素を取り出してDIVIDENTに格納
k=0;
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT[k] = NA1[j];
k += 1;
}

for(i=0 ; i<NA1.length-NA2.length+1 ; i++){
if(DIVIDENT.length==NA2.length){
//DIVIDENTの最大桁÷NA2の最大桁を仮にQUOTIENTと置く
QUOTIENT[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/NA2[NA2.length-1]);
}
else{
QUOTIENT[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/NA2[NA2.length-1]);
}
breaks=0;
while(breaks==0){
//QUOTIENTにNA2を掛けたDIVIDENTSUBをDIVIDENTと比較
DIVIDENTSUB = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTSUB);
if(SUBR[SUBR.length-1]<0){
QUOTIENT[0] -= 1;
breaks=0;
}
else{
breaks=1;
}
}
//RESに追加
RES.unshift(QUOTIENT[0]);
//DIVIDENTを初期化
for(j=0 ; j<DIVIDENT.length ; j++){
DIVIDENT[j] = 0;
}
//DIVIDENTに次の桁を代入してSUBRを加算
DIVIDENT[0] = NA1[NA1.length-NA2.length-1-i];
SUBR = mul(KETA,SUBR);
DIVIDENT = add(DIVIDENT,SUBR);
}	//forに対応
}	//elseに対応


//不要な0削除
var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
RES.pop()
}


return RES;
}





















function div(NA1,NA2){
var i,j,k,Q;
var RES=[];
var DIVIDENT=[];	//割られる数をNA2の桁にそろえたもの
var QUOTIENT=[];	//商の一桁
var QUOTIENT_MAX=[];	//商の一桁の上界
var QUOTIENT_MIN=[];
var DIVIDENTQ=[];	//DIVIDENTから引く数
var SUBR=[];	//余り
var ADDR=[];	//余りからNA2を引いたもの
var KETA=[];
var COMP;	//SUBRとNA2の大小比較用
var breaks = 1;	//for文抜け出し用
var VAR	//デバッグ用


QUOTIENT.push(0);
QUOTIENT_MAX.push(0);
QUOTIENT_MIN.push(0);
DIVIDENTQ.push(0);
SUBR.push(0);
ADDR.push(0);
KETA.push(10000000);
i=0;


if(NA1.length<NA2.length){
RES.push(0);
}

else{
//DIVIDENT初期化
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT.push(0);
}
//NA1からNA2と同じ桁数の要素を取り出してDIVIDENTに格納
k=0;
for(j=NA1.length-NA2.length ; j<NA1.length ; j++){
DIVIDENT[k] = NA1[j];
k += 1;
}

for(i=0 ; i<NA1.length-NA2.length+1 ; i++){
if(DIVIDENT.length==NA2.length){
//DIVIDENTの最大桁÷NA2の最大桁をQUOTIENT_MAXと置く
QUOTIENT_MAX[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor(DIVIDENT[DIVIDENT.length-1]/(NA2[NA2.length-1]+1));
}
else{
//前回の余りを足した場合
if(DIVIDENT.length>1){
QUOTIENT_MAX[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor((10000000*DIVIDENT[DIVIDENT.length-1]+DIVIDENT[DIVIDENT.length-2])/(NA2[NA2.length-1]+1));
}
//DIVIDENTの長さが1の場合
else{
QUOTIENT_MAX[0] = Math.floor((DIVIDENT[DIVIDENT.length-1])/NA2[NA2.length-1]);
QUOTIENT_MIN[0] = Math.floor((DIVIDENT[DIVIDENT.length-1])/(NA2[NA2.length-1]+1));
}
}
QUOTIENT[0] = QUOTIENT_MAX[0];

breaks=0;
//QUOTIENTにNA2を掛けたDIVIDENTQをDIVIDENTと比較
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
while(breaks==0){
//余りが負になった場合、QUOTIENTとQUOTIENT_MINの平均をQUOTIENTに代入
if(SUBR[SUBR.length-1]<0){
QUOTIENT[0] = Math.floor((QUOTIENT_MIN[0]+QUOTIENT[0])/2);
//もしそれでも大きすぎる場合QUOTIENTをQUOTIENT_MAXに代入
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
if(SUBR[SUBR.length-1]<0){
QUOTIENT_MAX[0] = QUOTIENT[0];
}
if(ADDR[ADDR.length-1]>=0){
QUOTIENT_MIN[0] = QUOTIENT[0];
}
breaks=0;
}
//余りがNA2より大きくなった場合、QUOTIENTとQUOTIENT_MANの平均をQUOTIENTに代入し、それをQUOTIENT_MINに代入
else if(ADDR[ADDR.length-1]>=0){
QUOTIENT[0] = Math.floor((QUOTIENT_MAX[0]+QUOTIENT[0])/2);
//もしそれでも小さすぎる場合QUOTIENTをQUOTIENT_MAXに代入
DIVIDENTQ = mul(QUOTIENT,NA2);
SUBR = sub(DIVIDENT,DIVIDENTQ);
ADDR = sub(SUBR,NA2);
if(SUBR[SUBR.length-1]<0){
QUOTIENT_MAX[0] = QUOTIENT[0];
}
if(ADDR[ADDR.length-1]>=0){
QUOTIENT_MIN[0] = QUOTIENT[0];
}
breaks=0;
}
else{
breaks=1;
}
}

//RESに追加
RES.unshift(QUOTIENT[0]);
//DIVIDENTを初期化
for(j=0 ; j<DIVIDENT.length ; j++){
DIVIDENT[j] = 0;
}
//DIVIDENTに次の桁を代入してSUBRを加算
DIVIDENT[0] = NA1[NA1.length-NA2.length-1-i];
SUBR = mul(KETA,SUBR);
DIVIDENT = add(DIVIDENT,SUBR);
}	//forに対応
}	//elseに対応


//不要な0削除
var reslength = RES.length;
for(i=0;i<reslength;i++){
if(RES[reslength-i-1]!=0){
break;
}
else if(RES.length!=1){
RES.pop()
}
}


return RES;
}





















function clr(){
test.a1.value = "";
test.a2.value = "";
test.result.value = "";
}
</script>


</font>





</td>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <tr>
              <td width="200" align="center">







</td>
              <td>
              
              </td>
            </tr>

          </tbody>
        </table>


	<br>
        <table width="780" border="0">
         
		<tbody>
            <tr>
              <td colspan="2" style="font-size : 13pt;" height="30"></td>
            </tr>
            <td width="200" align="center">
              

              <td>
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
              
        
              <table width="100%" cellspacing="1" cellpadding="2" border="0" bgcolor="#cccccc">
                

              </table>
              </td>
            </tr>
            
          </tbody>
        </table>
       



            </tr>
          </tbody>
        </table>
        <br>
        <br>
        <br>
        </td>
      </tr>
      <tr>
        <td style="height : 50px;" valign="bottom" bgcolor="#0000ff" align="center">
	<a href="index.html">HOME</a>｜
	<a href="jikoshoukai.html">自己紹介</a>｜
	<a href="">ブログ</a>｜
	<a href="develop.html">トピック</a> |
	<a href="">リンク</a></td>
      </tr>
      <tr>
        <td style="height : 50px;" bgcolor="#0000ff" align="center"><font style="font-size : 8pt;" color="#000000">&nbsp;<br>
        掲載内容の無断転載は禁じます。</font></td>
      </tr>
      <tr>
        <td style="font-size : 10pt;color : white;" height="100" bgcolor="#0000ff" background="" align="center"><strong style="font-size : 12pt;"></strong><br>
        連絡先 : kazuki.matsushita[at]icloud.com<br>
        <font style="font-size : 8pt;" color="#000000">Copyright (ｃ) Kazuki Matsushita  　All Rights Reserved.</font></td>
      </tr>
    </tbody>
  </table>
</div>
</body></html>
